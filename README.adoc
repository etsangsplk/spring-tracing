= Spring Tracing with Zipkin Brave and Spring Cloud Sleuth
Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:website: https://cloud.spring.io/spring-cloud-sleuth/

== Motivation
This example will demonstrate applying tracing capability to an existing
Spring or Spring Boot application.  We will begin by standing up an Spring MVC
Restful service, and then by adding the necessary pieces for leveraging
trace data and then shiping that to a Zipkin (Brave) server. Ultimately you could
ship to any service, yet this example will demonstrate trace propagation
across service requests Zipkin.

In this example, we will demonstrate how to stand up a simple RESTful web service
and, then - incrementaly add tracing capabilities to discover how we can break our
applications into descrete tracing priorities.  This example assumes you have an 
understainging of data metric and JVM tracing methods.  Today we find some operationly
production ready key assets to manage withing the organization.  Tracing your 
service codes involves a relatively complex process in which each new IO-bound
operation gets tagged with a 'spanId'.  Thus, each 'trace' contains the necessary
tree like structure to map out it's span positions in terms of service usage, 
service call order and any other key data the developer wants to emit.  

== Examnple Project Initialize
To start, you should have an existing application that includes Web, Lombok, and
JPA/H2 for persistence. Hit http://start.spring.io/starter.zip?dependencies=web,lombok,h2,jpa&type=maven-project&javaVersion=1.8&baseDir=spring-tracing&packageName=mcp.client&name=spring-tracing[start.spring.io] link
to download the base project. We'll start with standing up a REST controller.

.SimpleController
[source,java]
---
@RestController
class ClientRestController {
	private final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ClientRestController.class);
	private final RestTemplate restTemplate;

	public ClientRestController(RestTemplate rt) {
		this.restTemplate = rt;
	}

	@GetMapping("/backend")
	public String deviceNames(HttpServletRequest req) {
		String clientId = req.getHeader("client-id");
		log.info("clientId=" + clientId);
		return "Hello, " + clientId;
	}

	@GetMapping("/frontend")
	public String callBackend() {
		return restTemplate.getForObject("http://localhost:8080/backend", String.class);
	}
}
---

Then setup the logging properties:

.LoggingProperties
[source,script]
---
logging.pattern.level=%d{ABSOLUTE} [%X{traceId}/%X{spanId}] %-5p [%t] %C{2} - %m%n
logging.level.root=off
logging.level.mcp.cloudtrace=info
spring.application.name=spring-tracing
---

Startup the server by running `mvn spring-boot:run` at the command line.  We can 
test that the endpoint is up by accessing it's `/frontend` path. Take a look at 
the logs, and you should find some pretty vanilla output:

.Boot_app_output
[source,text]
---
...
2018-02-28 18:25:48.531 2018-02-28 18:25:48,531 [/] INFO  [http-nio-8080-exec-2] m.c.ClientRestController - clientId=null
 30145 --- [nio-8080-exec-2] mcp.cloudtrace.ClientRestController      : clientId=null
...
---

Notice that `%TraceId/%SpanId` are not being filled in yet.  Lets fix that by
registering an `org.springframework.web.servlet.HandlerInterceptor` specific to
zipkin. In this case we will use the `brave.spring.webmvc.TracingHandlerInterceptor`
that adds a zipkin span to every request.
Of important note is the use of a Trace Context.  While you have other options, 
this example uses SLF4j - which itself utilizes Managed Diagnostic Context(MDC). 
Thus, `brave.context.slf4j.MDCCurrentTraceContext` is a ready-made Trace Context that 
will be used to expose span data to slf4j as logging properties: 
`traceId, spanId, parentId`.

.Configure_zipkin_interceptor
[source,java]
---
	@Configureation
	public class WebTracingConfiguration extends WebMvcConfigurerAdapter {
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(TracingHandlerInterceptor.create(
					HttpTracing.create(Tracing
					.newBuilder()
					.currentTraceContext(MDCCurrentTraceContext.create())
					.build())));
		}
	}
---

So now, we can restart our service, and invoke the `/frontend` and observe 
the output in logs:

.Invokation_with_span
[source,text]
---
2018-02-28 18:49:51.200 2018-02-28 18:49:51,200 [6b5e99f057da5abd/1239a4f2e354ecdf] INFO  [http-nio-8080-exec-2] m.c.ClientRestController - clientId=null
 37142 --- [nio-8080-exec-2] mcp.cloudtrace.ClientRestController      : clientId=null
---



SLF4j 
 1 - Maintain some semblance of inter-process communication 
	 and apply to business Logic.
     HTTP Rest call 
	 	This demo will expose 2 Restful endpoints 
		One will call the other to demonstrate trace propigation across HTTP 
	 Finagle RPC call
	 	This demo will expose 2 finagle services
		"" trace propigation via Finagle (mysql)
	 WebSocket stream
	 	This demo will expose a socket service which receives
		it's stream via kafka
 	
 2 - Apply tracing logic
	- Starting with SLF4j MDC tracing
	- Adds Brave tracing without instrumentation
	- Adds Brave trace with trace shipping to zipkin
	- further trace shipping options

 3 - Stand up tracing aggregator (Brave, Actuator?)
 
 4 - Bring it together using Spring-cloud-sleuth


.Pom that enables tracing
[source,xml]
----
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<dependency>
			<groupId>io.zipkin.reporter2</groupId>
			<artifactId>zipkin-sender-okhttp3</artifactId>
			<version>${zipkin-reporter2.version}</version>
		</dependency>
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-instrumentation-spring-webmvc</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-instrumentation-spring-web</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<!-- slf4j -->
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-context-slf4j</artifactId>
			<version>${brave.version}</version>
		</dependency>        
----

A decription of the pom depenencies here !!!
 * Ship zipkin logs via http calls
 * enable slf4j MDC context propigation (for logging trace/spanc)
 * Adds B3-propigation for commuting trace/spans across HTTP client/service calls.

If you are using log4j, then you'll want to add these artifacts:

.Pom dependencies for log4j2, commons, JUL
[source,xml]
----
		<!-- use log4j2, Commons, or Util-->
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-context-log4j2</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.logging.log4j</groupId>
			<artifactId>log4j-jul</artifactId>
			<version>${log4j.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.logging.log4j</groupId>
			<artifactId>log4j-jcl</artifactId>
			<version>${log4j.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.logging.log4j</groupId>
			<artifactId>log4j-slf4j-impl</artifactId>
			<version>${log4j.version}</version>
		</dependency>
----

== Configure the application for brave tracing
