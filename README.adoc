= Spring Tracing with Zipkin Brave and Spring Cloud Sleuth
Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:website: https://cloud.spring.io/spring-cloud-sleuth/

== Motivation
This example will demonstrate applying tracing capability to an existing
Spring or Spring Boot application.  We will begin by standing up an Spring MVC
Restful service, and then by adding the necessary pieces for leveraging
trace data and then shiping that to a Zipkin (Brave) server. Ultimately you could
ship to any service, yet this example will demonstrate trace propagation
across service requests Zipkin.

In this example, we will demonstrate how to stand up an Spring application with
various degrees of tracing.  It will start without tracing, then incrementaly
add our tracing concerns. First lets take a look at some common trace nomenclature:

What is:
Trace data is composed of a parent:child tree structure.  Where a root node represents
the `trace` or overall journey, and each `span` represents an individual hop along the
route. Our application will demonstrate this kind of relationship:

    client -> </frontent> -> </backend> -> </backend2>
	  			AAA 		   AAA:BBB		 BBB:CCC
				  \
				    BBB
					 \
				       CCC
 
== Examnple Project Initialize
To start, you should have an existing application that includes Web, Lombok, and
JPA/H2 for persistence. Hit http://start.spring.io/starter.zip?dependencies=web,lombok,h2,jpa&type=maven-project&javaVersion=1.8&baseDir=spring-tracing&packageName=mcp.client&name=spring-tracing[start.spring.io] link
to download the base project. Find your favorite editor, and start with standing up a REST
controller.

.SimpleController
[source,java]
---
@SpringBootApplication
public class ClientTraceApplication {
	public static void main(String[] args) {
		SpringApplication.run(ClientTraceApplication.class, args);
	}
}

@Configuration
class TracingConfiguration {
	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate(); 
	}
}

@RestController
class ClientRestController {
	private final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ClientRestController.class);
	private final RestTemplate restTemplate;

	public ClientRestController(RestTemplate rt) {
		this.restTemplate = rt;
	}

	@GetMapping("/backend")
	public String deviceNames(HttpServletRequest req) {
		String clientId = req.getHeader("client-id");
		log.info("clientId=" + clientId);
		return "Hello, " + clientId;
	}

	@GetMapping("/frontend")
	public String callBackend() {
		return restTemplate.getForObject("http://localhost:8080/backend", String.class);
	}
}
---

Then setup the logging properties:

.LoggingProperties
[source,script]
---
logging.pattern.level=%d{ABSOLUTE} [%X{traceId}/%X{spanId}] %-5p [%t] %C{2} - %m%n
logging.level.root=off
logging.level.mcp.cloudtrace=info
spring.application.name=spring-tracing
---

Startup the server by running `mvn spring-boot:run` at the command line. And in another
terminal window (or tab), we can validate access to the endpoints.
Try curling `localhost:8080/frontend` first. Then switch to your server terminal and
observe the logs:

.Boot_app_output
[source,text]
---
...
2018-02-28 18:25:48.531 2018-02-28 18:25:48,531 [/] INFO  [http-nio-8080-exec-2] m.c.ClientRestController - clientId=null
 30145 --- [nio-8080-exec-2] mcp.cloudtrace.ClientRestController      : clientId=null
...
---

Notice that `%TraceId/%SpanId` are not being filled in yet.  Lets fix that by
registering an `org.springframework.web.servlet.HandlerInterceptor` that exhibits
trace instrumentation. In this case we will use the provided `brave.spring.webmvc.TracingHandlerInterceptor`
class for tracing Spring WEB/MVC/REST endpoints.

.Configure_zipkin_interceptor
[source,java]
---
	@Configureation
	public class WebTracingConfiguration extends WebMvcConfigurerAdapter {
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(TracingHandlerInterceptor.create(
					HttpTracing.create(Tracing
					.newBuilder()
					.currentTraceContext(MDCCurrentTraceContext.create())
					.build())));
		}
	}
---

Of important note is the use of a Trace Context.  While you have other options, 
this example uses SLF4j - which uses it's own version of Managed Diagnostic Context (MDC). 
Thus, `brave.context.slf4j.MDCCurrentTraceContext` is a ready-made Trace Context that 
will expose current trace and span ID's to slf4j as logging properties with the given
names: `traceId, spanId, parentId`. If you are using log4j instead, then a provided
class `brave.context.log4j2.ThreadContextCurrentTraceContext` will do the same for
log4j's ThreadContext.

So now, we can restart our service then invoke the `/frontend` and observe 
the output in logs:

.Invokation_with_span
[source,text]
---
2018-02-28 18:49:51.200 2018-02-28 18:49:51,200 [6b5e99f057da5abd/1239a4f2e354ecdf] INFO  [http-nio-8080-exec-2] m.c.ClientRestController - clientId=null
 37142 --- [nio-8080-exec-2] mcp.cloudtrace.ClientRestController      : clientId=null
---




SLF4j 
 1 - Maintain some semblance of inter-process communication 
	 and apply to business Logic.
     HTTP Rest call 
	 	This demo will expose 2 Restful endpoints 
		One will call the other to demonstrate trace propigation across HTTP 
	 Finagle RPC call
	 	This demo will expose 2 finagle services
		"" trace propigation via Finagle (mysql)
	 WebSocket stream
	 	This demo will expose a socket service which receives
		it's stream via kafka
 	
 2 - Apply tracing logic
	- Starting with SLF4j MDC tracing
	- Adds Brave tracing without instrumentation
	- Adds Brave trace with trace shipping to zipkin
	- further trace shipping options

 3 - Stand up tracing aggregator (Brave, Actuator?)
 
 4 - Bring it together using Spring-cloud-sleuth


.Pom that enables tracing
[source,xml]
----
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<dependency>
			<groupId>io.zipkin.reporter2</groupId>
			<artifactId>zipkin-sender-okhttp3</artifactId>
			<version>${zipkin-reporter2.version}</version>
		</dependency>
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-instrumentation-spring-webmvc</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-instrumentation-spring-web</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<!-- slf4j -->
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-context-slf4j</artifactId>
			<version>${brave.version}</version>
		</dependency>        
----

A decription of the pom depenencies here !!!
 * Ship zipkin logs via http calls
 * enable slf4j MDC context propigation (for logging trace/spanc)
 * Adds B3-propigation for commuting trace/spans across HTTP client/service calls.

If you are using log4j, then you'll want to add these artifacts:

.Pom dependencies for log4j2, commons, JUL
[source,xml]
----
		<!-- use log4j2, Commons, or Util-->
		<dependency>
			<groupId>io.zipkin.brave</groupId>
			<artifactId>brave-context-log4j2</artifactId>
			<version>${brave.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.logging.log4j</groupId>
			<artifactId>log4j-jul</artifactId>
			<version>${log4j.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.logging.log4j</groupId>
			<artifactId>log4j-jcl</artifactId>
			<version>${log4j.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.logging.log4j</groupId>
			<artifactId>log4j-slf4j-impl</artifactId>
			<version>${log4j.version}</version>
		</dependency>
----

== Configure the application for brave tracing
